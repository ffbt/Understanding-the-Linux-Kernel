### 2.3 Linux 中的分段

[DPL,RPL,CPL 之间的联系和区别](https://blog.csdn.net/better0332/article/details/3416749)

**DPL,RPL,CPL 之间的联系和区别**：

- CPL 是当前**进程**的权限级别 (Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于 cs 寄存器的低两位。

  当选择子成功装入 CS 寄存器后，相应的选择子中的 RPL 就变成了 CPL。因为它的位置变了，已经被装入到 CS 寄存器中了，所表达的意思也发生了变化——原来的要求等级已经得到了满足，就是当前自己的等级。

  选择子可以有许多个，因此 RPL 也就有许多个。而 CPL 就不同了，正在执行的代码在某一时刻就只有这个值唯一的代表程序的 CPL.

  另外特别要求 CS 与 SS 的特权级必须保持一致。

- RPL 说明的是**进程对段访问的请求权限 **(Request Privilege Level)，是对于**段选择符**而言的，每个段选择符有自己的 RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且 RPL 对每个段来说不是固定的，两次访问同一段时的 RPL 可以不同。RPL 可能会削弱 CPL 的作用，例如当前 CPL=0 的进程要访问一个数据段，它把段选择符中的 RPL 设为 3，这样虽然它对该段仍然只有特权为 3 的访问权限。

  RPL 的值由程序员自己来自由的设置，并不一定 RPL>=CPL，但是当 RPL<CPL 时，实际起作用的就是 CPL 了，因为访问时的特权检查是判断：EPL=max(RPL,CPL)<=DPL 是否成立，所以 RPL 可以看成是每次访问时的附加限制，RPL=0 时附加限制最小，RPL=3 时附加限制最大。所以你不要想通过来随便设置一个 rpl 来访问一个比 cpl 更内层的段。

- DPL 存储在**段描述符**中，规定访问该段的权限级别 (Descriptor Privilege Level)，每个段的 DPL 固定。

- 当进程访问一个段时，需要进程特权级检查，一般要求 DPL >= max {CPL, RPL}



**Intel 将代码分为：**

1. 非一致码：受到隔离的代码，只能在同一级别间相互访问

2. 一致码：不受到隔离的代码，允许被同等级或低等级代码调用



1. 对数据段和堆栈段访问时的特权级控制：

   要求访问数据段或堆栈段的程序的 CPL≤待访问的数据段或堆栈段的 DPL，同时选择子的 RPL≤待访问的数据段或堆栈段的 DPL，即程序访问数据段或堆栈段要遵循一个准则：只有相同或更高特权级的代码才能访问相应的数据段。这里，RPL 可能会削弱 CPL 的作用，访问数据段或堆栈段时，默认用 CPU 和 RPL 中的最小特权级去访问数据段，所以 max {CPL, RPL} ≤ DPL，否则访问失败。

2. 对代码段访问的特权级控制（代码执行权的特权转移）：

#### 2.3.1 Linux GDT

```s
ENTRY(cpu_gdt_table)
	.quad 0x0000000000000000	/* NULL descriptor */
	.quad 0x0000000000000000	/* 0x0b reserved */
	.quad 0x0000000000000000	/* 0x13 reserved */
	.quad 0x0000000000000000	/* 0x1b reserved */
	.quad 0x0000000000000000	/* 0x20 unused */
	.quad 0x0000000000000000	/* 0x28 unused */
	.quad 0x0000000000000000	/* 0x33 TLS entry 1 */
	.quad 0x0000000000000000	/* 0x3b TLS entry 2 */
	.quad 0x0000000000000000	/* 0x43 TLS entry 3 */
	.quad 0x0000000000000000	/* 0x4b reserved */
	.quad 0x0000000000000000	/* 0x53 reserved */
	.quad 0x0000000000000000	/* 0x5b reserved */

	.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
	.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
	.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */
	.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */

	.quad 0x0000000000000000	/* 0x80 TSS descriptor */
	.quad 0x0000000000000000	/* 0x88 LDT descriptor */

	/* Segments used for calling PnP BIOS */
	.quad 0x00c09a0000000000	/* 0x90 32-bit code */
	.quad 0x00809a0000000000	/* 0x98 16-bit code */
	.quad 0x0080920000000000	/* 0xa0 16-bit data */
	.quad 0x0080920000000000	/* 0xa8 16-bit data */
	.quad 0x0080920000000000	/* 0xb0 16-bit data */
	/*
	 * The APM segments have byte granularity and their bases
	 * and limits are set at run time.
	 */
	.quad 0x00409a0000000000	/* 0xb8 APM CS    code */
	.quad 0x00009a0000000000	/* 0xc0 APM CS 16 code (16 bit) */
	.quad 0x0040920000000000	/* 0xc8 APM DS    data */

	.quad 0x0000000000000000	/* 0xd0 - unused */
	.quad 0x0000000000000000	/* 0xd8 - unused */
	.quad 0x0000000000000000	/* 0xe0 - unused */
	.quad 0x0000000000000000	/* 0xe8 - unused */
	.quad 0x0000000000000000	/* 0xf0 - unused */
	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */
	
cpu_gdt_descr:
	.word GDT_ENTRIES*8-1
	.long cpu_gdt_table

	.fill NR_CPUS-1,8,0		# space for the other GDT descriptors
```

#### 2.3.2 Linux LDT